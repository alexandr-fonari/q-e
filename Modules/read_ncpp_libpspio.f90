
! Copyright (C) 2002-2008 Quantum ESPRESSO group
! This file is distributed under the terms of the
! GNU General Public License. See the file `License'
! in the root directory of the present distribution,
! or http://www.gnu.org/copyleft/gpl.txt .
!

#if defined(__LIBPSPIO)
#include "pspio_common.h"
#endif

MODULE read_ncpp_libpspio_module
  !  this module handles the reading of pseudopotential data
  USE constants,    ONLY: pi
  USE kinds,        ONLY: DP
  USE pseudo_types, ONLY: pseudo_upf
  USE radial_grids, ONLY: radial_grid_type, deallocate_radial_grid, allocate_radial_grid

#if defined(__LIBPSPIO)

  USE pspio_f90_types_m
  USE pspio_f90_lib_m
  !
  IMPLICIT NONE
  !
  CHARACTER(len=5),PARAMETER :: ANGULAR_CHR = 'SPDFG'
  !
  PRIVATE
  PUBLIC :: read_ncpp_libpspio
CONTAINS
!
!---------------------------------------------------------------------
SUBROUTINE read_ncpp_libpspio( unit, upf, grid, ierr )
  !---------------------------------------------------------------------
  ! Read pseudopotential in UPF format (either v.1 or v.2)
  ! ierr = -1 : read UPF v.1 
  ! ierr =  0 : read UPF v.2 
  ! ierr =  1 : not an UPF file, or error while reading

  IMPLICIT NONE
  INTEGER,INTENT(IN)             :: unit      ! i/o unit
  TYPE(pseudo_upf),INTENT(INOUT) :: upf       ! the pseudo data
  TYPE(radial_grid_type),OPTIONAL,INTENT(INOUT),TARGET :: grid
  INTEGER,INTENT(OUT) :: ierr
  !
  INTEGER :: ios, i, nw, n, l
  CHARACTER(len=2)  :: els  ! nl label
  CHARACTER(len=255)  :: filename  ! i/o filename

  !LIBPSPIO_API
  INTEGER :: pio_fmt
  TYPE(pspio_f90_pspdata_t) :: pspdata
  ierr = 0

  ! TODO error checking from INQUIRE
  INQUIRE(unit=unit, name=filename)
  !# CALL errore('read_upf_libpspio', 'filename: '//filename, 1)

  ierr = pspio_f90_pspdata_init(pspdata)
  if (ierr /= 0) ierr = pspio_f90_error_flush()

  pio_fmt = PSPIO_FMT_UPF
  !WRITE(*,*) "__DEBUG_PSPIO__0"
  ierr = pspio_f90_pspdata_read(pspdata, pio_fmt, filename)
  IF (ierr /= 0) ierr = pspio_f90_error_flush()

  ierr = 0  
  CALL read_pseudo_header(upf, pspdata, ierr)
  upf%generated='Generated by new atomic code, or converted to UPF format'

  ierr = 0
  CALL read_pseudo_mesh(upf, pspdata, grid, ierr)

  ierr = 0
  if ( upf%nlcc ) then
    CALL read_pseudo_nlcc (upf, pspdata, ierr)
  else
     ALLOCATE( upf%rho_atc( upf%mesh ) )
     upf%rho_atc = 0.0_DP
  endif

  ierr = 0
  CALL read_pseudo_local(upf, pspdata, ierr)

  ierr = 0
  CALL read_pseudo_nl(upf, pspdata, ierr)

  ierr = 0
  CALL read_pseudo_pswfc(upf, pspdata, ierr)

  ierr = 0
  CALL read_pseudo_rhoatom(upf, pspdata, ierr)

  ierr = 0
  CALL pspio_f90_pspdata_free(pspdata)

  RETURN
END SUBROUTINE read_ncpp_libpspio

!---------------------------------------------------------------------

SUBROUTINE read_pseudo_header (upf, pspdata, ierr)

  IMPLICIT NONE
  ! inout
  TYPE(pseudo_upf),INTENT(INOUT) :: upf       ! the pseudo data
  TYPE(pspio_f90_pspdata_t),INTENT(IN) :: pspdata
  INTEGER,INTENT(OUT) :: ierr
  ! local
  TYPE(pspio_f90_xc_t):: pspxc
  TYPE(pspio_f90_state_t) :: pspstate
  INTEGER :: i, l, n
  REAL(DP) :: j

  ! TODO: Check these values
  upf%q_with_l=.false.
  upf%has_so=.false.
  upf%has_gipaw = .false.
  !
  ! read_pseudo_header equivalent
  !
  upf%nv='0'
  upf%typ='NC' ! otherwise libpspio quits (US/PAW not implemented, for now)
  upf%tvanp = .false.
  upf%tpawp = .false.
  upf%tcoulombp = .false.
  ! end type: NC
  !
  CALL pspio_f90_pspdata_get_symbol(pspdata, upf%psd) ! Be careful: char* conversion
  !WRITE(*,*) upf%psd

  CALL pspio_f90_pspdata_get_xc(pspdata, pspxc)

  upf%nlcc = pspio_f90_xc_has_nlcc(pspxc)
  !WRITE(*,*) upf%nlcc

  upf%dft = 'SLA  PZ   NOGX NOGC'
  !CALL pspio_f90_xc_dft_str(pspxc, upf%dft)
  !WRITE(*,*) upf%dft

  CALL pspio_f90_pspdata_get_zvalence(pspdata, upf%zp)
  !WRITE(*,*) upf%zp

  ! TODO
  upf%etotps=-7.47480832270_DP
  upf%ecutwfc=0.0_DP
  upf%ecutrho=0.0_DP
  ! end TODO

  CALL pspio_f90_pspdata_get_kb_l_max(pspdata, upf%lmax)
  !WRITE(*,*) upf%lmax

  CALL pspio_f90_pspdata_get_n_states(pspdata, upf%nwfc)
  !WRITE(*,'("nwfc: ", I6)') upf%nwfc

  CALL pspio_f90_pspdata_get_n_kbproj(pspdata, upf%nbeta)
  !WRITE(*,'("nbeta: ", I6)') upf%nbeta

  ALLOCATE( upf%els( upf%nwfc ), upf%lchi( upf%nwfc ), upf%oc( upf%nwfc ) )
  
  DO i = 1, upf%nwfc
     CALL pspio_f90_pspdata_get_state(pspdata, i, pspstate)
     CALL pspio_f90_state_get_qn(pspstate, n, l, j)

     upf%lchi (i) = l

     upf%els(i) = ''
     !WRITE(upf%els(i),'(I1,A1)') n, ANGULAR_CHR(l+1:l+2) ! starts from 0
     !WRITE(*,*) upf%els(i)

     CALL pspio_f90_state_get_occ(pspstate, upf%oc(i))
  ENDDO

  RETURN
END SUBROUTINE read_pseudo_header

!---------------------------------------------------------------------

SUBROUTINE read_pseudo_mesh (upf, pspdata, grid, ierr)

  IMPLICIT NONE
  ! inout
  TYPE(pseudo_upf),INTENT(INOUT) :: upf       ! the pseudo data
  TYPE(pspio_f90_pspdata_t),INTENT(IN) :: pspdata
  TYPE(radial_grid_type),OPTIONAL,INTENT(INOUT),TARGET :: grid
  INTEGER,INTENT(OUT) :: ierr
  ! local
  TYPE(pspio_f90_mesh_t) :: pspmesh
  INTEGER :: i, l, n
  REAL(DP) :: j

  upf%grid => grid
  CALL pspio_f90_pspdata_get_mesh(pspdata, pspmesh)

  !ierr = pspio_f90_error_flush()
  CALL pspio_f90_mesh_get_np(pspmesh, upf%mesh)
  !WRITE(*,'("Mesh number of points: ", I6)') upf%mesh

  upf%grid%mesh = upf%mesh
  CALL allocate_radial_grid(upf%grid,upf%grid%mesh)

  IF(associated(upf%grid)) THEN
     upf%r   => upf%grid%r
     upf%rab => upf%grid%rab
  ELSE
     ALLOCATE( upf%r( upf%mesh ), upf%rab( upf%mesh ) )
  ENDIF

  upf%r   = 0.0_DP
  upf%rab = 0.0_DP

  CALL pspio_f90_mesh_get_r(pspmesh, upf%r)
  CALL pspio_f90_mesh_get_rab(pspmesh, upf%rab)

  RETURN
END SUBROUTINE read_pseudo_mesh

!---------------------------------------------------------------------

SUBROUTINE read_pseudo_local (upf, pspdata, ierr)
  IMPLICIT NONE
  ! inout
  TYPE(pseudo_upf),INTENT(INOUT) :: upf       ! the pseudo data
  TYPE(pspio_f90_pspdata_t),INTENT(IN) :: pspdata
  INTEGER,INTENT(OUT) :: ierr
  ! local
  TYPE(pspio_f90_potential_t) :: psppot_local
  INTEGER                     :: i

  ALLOCATE( upf%vloc( upf%mesh ) )

  CALL pspio_f90_pspdata_get_vlocal(pspdata, psppot_local)
  CALL pspio_f90_potential_eval_v(psppot_local, upf%mesh, upf%r, upf%vloc)

  ! to Rydbergs from Hartrees
  DO i = 1, upf%mesh
    upf%vloc(i) = upf%vloc(i) * 2.0_DP
  ENDDO

  RETURN
END SUBROUTINE read_pseudo_local

!---------------------------------------------------------------------

SUBROUTINE read_pseudo_nlcc (upf, pspdata, ierr)
  IMPLICIT NONE
  ! inout
  TYPE(pseudo_upf),INTENT(INOUT)       :: upf       ! the pseudo data
  TYPE(pspio_f90_pspdata_t),INTENT(IN) :: pspdata
  INTEGER,INTENT(OUT)                  :: ierr
  ! local
  TYPE(pspio_f90_xc_t)        :: pspxc
  INTEGER                     :: i

  ALLOCATE( upf%rho_atc( upf%mesh ) )

  CALL pspio_f90_pspdata_get_xc(pspdata, pspxc)
  CALL pspio_f90_xc_core_density_eval(pspxc, upf%mesh, upf%r, upf%rho_atc)

  RETURN
END SUBROUTINE read_pseudo_nlcc

!---------------------------------------------------------------------

SUBROUTINE read_pseudo_nl (upf, pspdata, ierr)

  IMPLICIT NONE
  ! inout
  TYPE(pseudo_upf),INTENT(INOUT) :: upf       ! the pseudo data
  TYPE(pspio_f90_pspdata_t),INTENT(IN) :: pspdata
  INTEGER,INTENT(OUT) :: ierr
  ! local
  TYPE(pspio_f90_projector_t) :: pspproj
  INTEGER :: i, n

  ! TODO: Check this
  upf%qqq_eps = -1._dp
  !
  IF ( upf%nbeta == 0) THEN
     upf%nqf = 0
     upf%nqlc= 0
     upf%kkbeta = 0
     ALLOCATE( upf%kbeta( 1 ) )
     ALLOCATE( upf%lll( 1 ) )
     ALLOCATE( upf%beta( upf%mesh, 1 ) )
     ALLOCATE( upf%dion( 1, 1 ) )
     ALLOCATE( upf%rinner( 1 ) )
     ALLOCATE( upf%qqq   ( 1, 1 ) )
     ALLOCATE( upf%qfunc ( upf%mesh, 1 ) )
     ALLOCATE( upf%qfcoef( 1, 1, 1, 1 ) )
     ALLOCATE( upf%rcut( 1 ) )
     ALLOCATE( upf%rcutus( 1 ) )
     ALLOCATE( upf%els_beta( 1 ) )

     RETURN
  END IF

  ALLOCATE( upf%kbeta( upf%nbeta ) )
  ALLOCATE( upf%lll( upf%nbeta ) )
  ALLOCATE( upf%beta( upf%mesh, upf%nbeta ) )
  ALLOCATE( upf%dion( upf%nbeta, upf%nbeta ) )
  ALLOCATE( upf%rcut( upf%nbeta ) )
  ALLOCATE( upf%rcutus( upf%nbeta ) )
  ALLOCATE( upf%els_beta( upf%nbeta ) )

  upf%kkbeta = 0  
  upf%lll    = 0  
  upf%beta   = 0.0_DP
  upf%dion   = 0.0_DP
  upf%rcut   = 0.0_DP
  upf%rcutus = 0.0_DP
  upf%els_beta = '  '

  DO i = 1, upf%nbeta

    ierr = 0
    CALL pspio_f90_pspdata_get_kb_projector(pspdata, i, pspproj)

    ierr = 0
    CALL pspio_f90_projector_get_l(pspproj, upf%lll(i))

    upf%kbeta(i) = upf%mesh
    !WRITE(*,'("kbeta_i: ", I0)') upf%kbeta(i)

    upf%kkbeta = MAX ( upf%kkbeta, upf%kbeta(i) )

    ierr = 0
    CALL pspio_f90_projector_eval_v(pspproj, upf%kbeta(i), upf%r, upf%beta(:,i))

    ! to r*Rydbergs from Hartrees
    DO n = 1, upf%mesh
      upf%beta(n,i) = upf%beta(n,i) * upf%r(n) * 2.0_DP
    ENDDO
    !WRITE(*,*) (upf%beta(n, i), n=1,upf%mesh)
    !WRITE(*,'("=============")')

    ! TODO: True only for NC PP
    ierr = 0
    CALL pspio_f90_projector_get_energy( pspproj, upf%dion(i,i) )

    ! to 1/Rydbergs from 1/Hartrees
    upf%dion(i,i) = upf%dion(i,i) / 2.0_DP

    !TODO: upf%rcut(nb), upf%rcutus(nb) upf%els_beta(nb)
  ENDDO

  RETURN
END SUBROUTINE read_pseudo_nl

!---------------------------------------------------------------------

SUBROUTINE read_pseudo_pswfc (upf, pspdata, ierr)
  IMPLICIT NONE
  ! inout
  TYPE(pseudo_upf),INTENT(INOUT) :: upf       ! the pseudo data
  TYPE(pspio_f90_pspdata_t),INTENT(IN) :: pspdata
  INTEGER,INTENT(OUT) :: ierr
  ! local
  TYPE(pspio_f90_state_t) :: pspstate
  INTEGER :: i, n

  ALLOCATE( upf%chi( upf%mesh, MAX( upf%nwfc, 1 ) ) )
  upf%chi = 0.0_DP

  DO i = 1, upf%nwfc

    CALL pspio_f90_pspdata_get_state(pspdata, i, pspstate)

    ierr = 0
    CALL pspio_f90_state_wf_eval_v(pspstate, upf%mesh, upf%r, upf%chi(:,i))

    ! to i-th radial atomic orbital * r from to i-th radial atomic orbital
    DO n = 1, upf%mesh
      upf%chi(n,i) = upf%chi(n,i) * upf%r(n)
    ENDDO
    !WRITE(*,*) (upf%chi(n,i),n=1,upf%mesh)
    !WRITE(*,'("=============")')

  ENDDO

  RETURN
END SUBROUTINE read_pseudo_pswfc

!---------------------------------------------------------------------

SUBROUTINE read_pseudo_rhoatom (upf, pspdata, ierr)
  IMPLICIT NONE
  ! inout
  TYPE(pseudo_upf),INTENT(INOUT) :: upf       ! the pseudo data
  TYPE(pspio_f90_pspdata_t),INTENT(IN) :: pspdata
  INTEGER,INTENT(OUT) :: ierr
  ! local
  TYPE(pspio_f90_state_t) :: pspstate
  INTEGER :: i

  ALLOCATE( upf%rho_at( upf%mesh ) )

  ierr = 0
  CALL pspio_f90_pspdata_rho_valence_eval(pspdata, upf%mesh, upf%r, upf%rho_at)

  ! to Rho * 4 * Pi * r^2 from Rho
  upf%rho_at(1:upf%mesh) = upf%rho_at(1:upf%mesh) * 4.0_DP * pi * upf%r(1:upf%mesh)**2
  !WRITE(*,*) (upf%rho_at(i),i=1,upf%mesh)

  RETURN
END SUBROUTINE read_pseudo_rhoatom

#endif

END MODULE read_ncpp_libpspio_module
